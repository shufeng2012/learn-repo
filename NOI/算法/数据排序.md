# 选择排序

**基本思想：** 每一次从还未排序的数组中选出最大或最小的元素放在还未排序的数组的最前面，直到所有元素全部排序完毕，复杂度$O(n^2)$

## 示意图

`[nums]`中的数表示未排序的数组

```text
[1,5,2,3,4]
1,[5,2,3,4]
1,2,[5,3,4]
1,2,3,[5,4]
1,2,3,4,[5]
1,2,3,4,5
```

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int a[6]={0,1,5,2,3,4};
    for(int i=1;i<=5;i++){
        int k=i;
        for(int j=i+1;j<=5;j++)
            if(a[j]<a[k]) k=j;
        if(k!=i) swap(a[i],a[k]);
    }
    return 0;
}
```

# 冒泡排序

**基本思想：** 每一次判断两个相邻的数，前一个数是否大于或小于另一个数，是则交换（相当于把最大或最小的数放到最后），复杂度$O(n^2)$

## 示意图

`n1_n2`表示n1和n2作比较

```text
3_1,5,4,2
1,3_5,4,2
1,3,5_4,2
1,3,4,5_2
1,3,4,2,5
```

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int a[6]={0,3,1,5,4,2};
    for(int i=1;i<=5;i++)
        for(int j=1;j<=5-i;j++)
            if(a[j]>a[j+1])
                swap(a[j],a[j+1]);
    return 0;
}
```

# 插入排序

**基本思想：** 像扑克牌一样，把一个数插入到它正确的位置，复杂度$O(n^2)$

## 示意图

`[nums]`表示已经有序的数组

```text
[3],1,5,4,2
[1,3],5,4,2
[1,3,5],4,2
[1,3,4,5],2
[1,2,3,4,5]
```

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int a[6]={0,3,1,5,4,2};
    for(int i=1;i<=5;i++){
        int j;
        for(j=i-1;j>=1;j--)
            if(a[j]<=a[i]) break;
        if(j!=i-1){
            int tmp=a[i];
            int k;
            for(k=i-1;k>j;k--)
                a[k+1]=a[k];
            a[k+1]=tmp;
        }
    }
    return 0;
}
```

# 桶排序

**基本思想：** 将每个数在数组中出现的次数放在另一个次数数组里，然后按顺序输出

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int a[6]={0,3,1,2,5,4};
    int cnt[6]={0};
    for(int i=1;i<=5;i++)
        cnt[a[i]]++;
    for(int i=1;i<=5;i++)
        if(cnt[i]) a[i]=i;
    return 0;
}
```

# 快速排序

**基本思想：** 
